{% extends 'base.html' %}

{% block content_main %}
  <!-- Title -->
  <div class="card card-body p-2">
    <p class="lead card-text text-center mb-2">
      {% if g.mode == 'day' or g.mode == 'month' %}
        <a href="{{ prev_url }}">
          <i class="fas fa-angle-left"></i>
        </a>
      {% endif %}
      <span>{{ datetime }}</span>
      {% if g.mode == 'day' or g.mode == 'month' %}
        <a href="{{ next_url }}">
          <i class="fas fa-angle-right"></i>
        </a>
      {% endif %}
    </p>
    <p class="text-muted text-center p-0 m-0">{{ meter_id }}</p>
  </div>
  <!-- Chart -->
  <div class="card mt-2 mb-4">
    <div class="card-img-top">
      <canvas id="chart" class="card-text m-0"></canvas>
    </div>
  </div>
  <!-- Statistics -->
  {% include "statistics.html" %}
  <!-- Table -->
  {% include "table.html" %}
{% endblock %}

{% include "price_modal.html" %}

{% block content_js %}
  <script>
      {% if g.mode == 'day' %}
          window.resolution = 60;
      {% endif %}


      document.getElementById('meterReadingsButton').onclick = meterReadingsChanged;
      document.getElementById('priceInput').oninput = priceInputChanged;
      document.getElementById('priceInputRange').oninput = priceInputRangeChanged;

      function setResInputEvents() {
          const resInputList = document.getElementsByName('res');
          for (let resInput of resInputList) {
              // Cannot use arrow function as "this" represents the function owner, not the function caller
              resInput.onchange = function () {
                  setResolution(this.value);
              }
          }
      }

      /* Chart functions */
      function makeChart() {
          /**
           * Update the chart according to the current response data
           * **/
          moment.locale('de');    // Set Moment.js to german language
          setChartSettings();

          let requestData = {{ g.data['meter_data']|tojson }};
          window.meterData = {  // Object for storing meter data
              datetimes: [],
              loadDiffs: [],
              meterReadings: [],
              hour: {
                  datetimes: [],
                  loadDiffs: [],
                  meterReadings: []
              },
              quarter: {
                  datetimes: [],
                  loadDiffs: [],
                  meterReadings: []
              }
          };

          requestData.forEach(d => {
              window.meterData.quarter.datetimes.push(d.datetime);
              window.meterData.quarter.loadDiffs.push(d.diff);
              window.meterData.quarter.meterReadings.push(d.reading);

              if (moment(d.datetime).minute() % 60 === 0) {
                  window.meterData.hour.datetimes.push(d.datetime);
                  window.meterData.hour.loadDiffs.push(d.diff);
                  window.meterData.hour.meterReadings.push(d.reading);
              }
          });

          let res = {{ g.res }};
          if (res === 60) {
              window.meterData.datetimes = window.meterData.hour.datetimes;
              window.meterData.loadDiffs = window.meterData.hour.loadDiffs;
              window.meterData.meterReadings = window.meterData.hour.meterReadings;
          } else {
              window.meterData.datetimes = window.meterData.quarter.datetimes;
              window.meterData.loadDiffs = window.meterData.quarter.loadDiffs;
              window.meterData.meterReadings = window.meterData.quarter.meterReadings;
          }

          setResInputEvents();

          // x-Axis values and settings
          let formattedLabels = [];
          {% if g.mode == 'interval' or g.mode == 'month' %}
              window.meterData.datetimes.forEach(t => formattedLabels.push(moment(t).format("L")));
          {% elif g.mode == 'year' %}
              window.meterData.datetimes.forEach(t => formattedLabels.push(moment(t).format("MMMM")));
          {% else %}
              window.meterData.datetimes.forEach(t => formattedLabels.push(moment(t).format("LT")));
          {% endif %}
          window.chart.data.labels = formattedLabels;

          // y-Axis values and settings
          window.chart.data.datasets[0].data = window.meterData.loadDiffs;  // Add loadDiffs to chart
          if (document.getElementById('meterReadingsButton').classList.contains('active')) {
              window.chart.data.datasets[1].data = window.meterData.meterReadings;  // Add meterReadings to chart
          }
          window.chart.update();
      }

      function setChartSettings() {
          /**
           * Setup chart with the settings stored in the chart_settings.js file
           * **/

          const ctx = document.getElementById("chart").getContext('2d');
          window.chart = new Chart(ctx, {
              type: "bar",
              data: {
                  datasets: [{
                      label: "Lastgang",
                      backgroundColor: "rgba(255, 128, 0, 0.2)",
                      borderColor: "rgb(255, 128, 0)",
                      borderWidth: 1,
                      yAxisID: "y-axis-load",
                  }]
              },
              options: {
                  scales: {
                      xAxes: [{
                          scaleLabel: {
                              display: true,
                              labelString: "Zeitpunkt",
                          },
                          gridLines: {
                              offsetGridLines: true
                          }
                      }],
                      yAxes: [{
                          type: "linear",
                          display: true,
                          position: "left",
                          id: "y-axis-load",
                          scaleLabel: {
                              display: true,
                              labelString: "Lastgang [{{ unit }}]",
                          },
                          ticks: {
                              beginAtZero: true
                          }
                      }, {
                          type: "linear",
                          display: false,
                          position: "right",
                          id: "y-axis-energy",
                          scaleLabel: {
                              display: true,
                              labelString: "Zählerstand [kWh]",
                          },
                          gridLines: {
                              drawOnChartArea: false,
                          }
                      }]
                  },
                  tooltips: {
                      mode: "index",
                      // Custom tooltip settings
                      callbacks: {
                          label: function (tooltipItem, data) {
                              if (tooltipItem.datasetIndex === 0) {
                                  return tooltipItem.yLabel + ' {{ unit }}';
                              } else {
                                  return tooltipItem.yLabel + " kWh";
                              }
                          },
                          footer: function (tooltipItem, data) {
                              let kwhPrice;
                              let load = tooltipItem[0].yLabel;
                              let price = document.getElementById("priceInput").value / 100;
                              // let price = 0.3;
                              // kwhPrice = calculatePrice(load, price);
                              {% if g.mode == 'interval' or g.mode == 'month' %}
                                  kwhPrice = load * price / 24;
                              {% elif g.fmt == 'year' %}
                                  kwhPrice = load * price / 12;
                              {% else %}
                                  kwhPrice = load * price / 60 * window.resolution;
                              {% endif %}

                              return "Kosten: " + kwhPrice.toFixed(2) + ' €';
                          },
                      },
                      footerFontStyle: "normal"
                  }
              }
          });
      }

      function meterReadingsChanged() {
          /**
           * Add and remove the meter value line graph from the chart
           * **/

          if (!document.getElementById('meterReadingsButton').classList.contains('active')) { // Add line graph
              if (window.chart.data.datasets.length === 1) {   // Add line graph if not already in chart
                  window.chart.data.datasets.push({
                      label: 'Zählerstand',
                      data: window.meterData.meterReadings,
                      backgroundColor: "rgba(255, 0, 0, 0.2)",
                      borderColor: "rgb(255, 0, 0)",
                      borderWidth: 1,
                      type: "line",
                      yAxisID: 'y-axis-energy'
                  });
                  window.chart.options.scales.yAxes[1].display = true;
              } else {
                  window.chart.data.datasets[1].data = window.meterData.meterReadings;  // Update line graph values if already in chart
              }
          } else if (window.chart.data.datasets.length === 2) {    // Remove line graph if already in chart
              window.chart.data.datasets.pop();
              window.chart.options.scales.yAxes[1].display = false;
          }

          window.chart.update();
      }

      function setResolution(res) {
          if (res === "60") {
              window.meterData.datetimes = window.meterData.hour.datetimes;
              window.meterData.loadDiffs = window.meterData.hour.loadDiffs;
              window.meterData.meterReadings = window.meterData.hour.meterReadings;
          } else {
              window.meterData.datetimes = window.meterData.quarter.datetimes;
              window.meterData.loadDiffs = window.meterData.quarter.loadDiffs;
              window.meterData.meterReadings = window.meterData.quarter.meterReadings;
          }
          let formattedLabels = [];
          window.meterData.datetimes.forEach(t => formattedLabels.push(moment(t).format("LT")));
          window.chart.data.labels = formattedLabels;
          window.chart.data.datasets[0].data = window.meterData.loadDiffs;
          if (window.chart.data.datasets.length === 2) {
              window.chart.data.datasets[1].data = window.meterData.meterReadings;
          }
          window.chart.update();
      }

      function priceInputChanged() {
          const currentVal = document.getElementById('priceInput').value;
          document.getElementById('priceInputRange').value = currentVal;
          calcPrice(currentVal);
      }

      function priceInputRangeChanged() {
          const currentVal = document.getElementById('priceInputRange').value;
          document.getElementById('priceInput').value = currentVal;
          calcPrice(currentVal);
      }

      /* Price functions */
      function calcPrice(val) {
          let priceCollection = document.getElementsByClassName('cost');
          const diffCollection = document.getElementsByClassName('diff');
          const price = val / 100;

          let priceSum = price * {{ g.data['sum'] }};
          document.getElementById('cost').innerText = `${priceSum.toFixed(2)} €`;

          for (let i = 0; i < priceCollection.length; i++) {
              let cost = 0.0;
              {% if g.mode == 'interval' or g.mode == 'month' %}
                  cost = parseFloat(diffCollection[i].innerHTML) * price / 24;
              {% elif g.mode == 'year' %}
                  cost = parseFloat(diffCollection[i].innerHTML) * price / 12;
              {% else %}
                  cost = parseFloat(diffCollection[i].innerHTML) * price / 60 * window.resolution;
              {% endif %}

              priceCollection[i].innerHTML = cost.toFixed(3)
          }
      }

      makeChart();
      calcPrice(document.getElementById('priceInput').value);
  </script>
{% endblock %}